---
title: JavaScript 如何遍历对象
excerpt: 在 JavaScript 中遍历对象的方法有多种，包括 for...in 循环、Object.keys()、Object.values()、Object.entries()、Object.getOwnPropertyNames() 和 Reflect.ownKeys()。每种方法有其适用场景、优缺点和潜在陷阱。
publishDate: 'Mar 16 2020'
featureImage:
  src: '/post-13.webp'
  alt: Stairs
seo:
  image:
    src: '/post-13.jpg'
---

在 JavaScript 中遍历对象的方法有多种，包括 `for...in` 循环、`Object.keys()`、`Object.values()`、`Object.entries()`、`Object.getOwnPropertyNames()` 和 `Reflect.ownKeys()`。每种方法有其适用场景、优缺点和潜在陷阱，以下是详细分析，并提供最佳实践建议。

---

### 1. for...in 循环

**描述**：`for (let key in obj)` 遍历对象的可枚举字符串键，包括原型链上的继承属性。

**适用场景**：

- 需要直接访问键和值（通过 `obj[key]`），尤其在动态属性处理时。
- 兼容旧环境，适合不支持现代方法的老项目。
- 简单对象检查或快速迭代。

**可能存在的陷阱**：

- **继承属性**：会遍历原型链上的属性（如 `Object.prototype.toString`），可能导致意外行为。
- **不包括符号键**：无法处理 `Symbol` 键。
- **遍历顺序**：不保证（通常按插入顺序，但非标准）。
- **对象修改**：遍历中添加或删除属性可能导致不一致结果。

**优缺点**：

- **优点**：语法简单，无需创建额外数组，直接访问键值；性能较高（无数组开销）。
- **缺点**：包含原型链属性，需额外检查（如 `hasOwnProperty`）；不适合现代代码（符号键或不可枚举属性）。

**最佳实践**：

- 始终使用 `Object.prototype.hasOwnProperty.call(obj, key)` 检查是否为自身属性，防止原型污染。
- 避免在数组上使用（数组用 `for...of` 或 `Array.prototype.forEach`）。
- 适合简单对象遍历，但优先考虑更现代方法。

---

### 2. Object.keys(obj)

**描述**：返回对象自身可枚举字符串键的数组。

**适用场景**：

- 需要键列表进行排序、过滤或映射。
- 与 `forEach`、`map` 等数组方法结合。
- 构建新对象或检查属性存在。

**可能存在的陷阱**：

- **仅限可枚举**：忽略不可枚举属性（通过 `Object.defineProperty` 设置 `enumerable: false`）。
- **无符号键**：不包括 `Symbol` 键。
- **额外开销**：生成数组增加内存和性能成本。
- **Proxy 行为**：如果对象是 Proxy，可能触发 getter/setter。

**优缺点**：

- **优点**：只遍历自身属性，排除原型链；返回数组便于链式操作（如 `sort()`、`filter()`）。
- **缺点**：仅提供键，需额外 `obj[key]` 访问值；不包括所有属性类型。

**最佳实践**：

- 结合 `for...of` 或 `Array.prototype.forEach` 遍历。
- 对于大对象，缓存 `Object.keys` 结果避免重复调用。
- 优先于 `for...in`，适合现代代码。

---

### 3. Object.values(obj)

**描述**：返回对象自身可枚举字符串键对应值的数组（ES2017+）。

**适用场景**：

- 仅需值列表，如求和、统计或值处理。
- 与 `reduce`、`filter` 等数组方法结合。
- 快速提取值进行操作。

**可能存在的陷阱**：

- **值顺序**：依赖键的插入顺序，但不保证。
- **无符号键**：不包括 `Symbol` 键或不可枚举属性。
- **值类型**：值可能是 `undefined` 或 `null`，需检查以防后续操作报错。
- **数组开销**：返回数组增加内存成本。

**优缺点**：

- **优点**：直接获取值，适合值-centric 操作；现代且简洁。
- **缺点**：丢失键信息，无法直接关联键；不包括所有属性。

**最佳实践**：

- 如果需要键值对应，结合 `Object.keys` 或 `Object.entries`。
- 用于不可变操作，避免修改原对象。
- 处理值时检查类型（如 `typeof` 或 null 检查）。

---

### 4. Object.entries(obj)

**描述**：返回对象自身可枚举字符串键的键值对数组（`[[key, value]]` 形式，ES2017+）。

**适用场景**：

- 需要键和值，如转换为 Map、JSON 或对象克隆。
- 与 `for...of` 结合解构遍历（如 `for (const [k, v] of Object.entries(obj))`）。
- 复杂对象操作或转换。

**可能存在的陷阱**：

- **仅可枚举**：不包括符号键或不可枚举属性。
- **性能开销**：返回二维数组，内存和计算成本较高。
- **顺序**：依赖插入顺序，但非标准保证。
- **引用值**：值是对象引用，修改会影响原对象。

**优缺点**：

- **优点**：提供完整键值信息；解构语法提升可读性；支持现代转换（如 `Map`）。
- **缺点**：内存开销大（二维数组）；不适合只需键或值的场景。

**最佳实践**：

- 优先用于现代遍历，结合解构提升代码清晰度。
- 与 `Array.from` 或 spread 操作符（如 `[...Object.entries(obj)]`）转换其他结构。
- 避免在性能敏感场景（如大对象）频繁使用。

---

### 5. Object.getOwnPropertyNames(obj)

**描述**：返回对象自身所有字符串键（包括不可枚举）的数组。

**适用场景**：

- 需要所有字符串键（如反射、调试）。
- 检查隐藏属性（如数组的 `length`）。
- 元编程或低级对象操作。

**可能存在的陷阱**：

- **无符号键**：不包括 `Symbol` 键。
- **不可枚举属性**：可能暴露内部属性，需谨慎处理。
- **顺序**：不保证（通常插入顺序）。
- **Proxy 复杂性**：与 Proxy 对象交互可能触发意外行为。

**优缺点**：

- **优点**：比 `Object.keys` 更全面，包括不可枚举属性。
- **缺点**：仅字符串键；需额外访问值；不适合日常遍历。

**最佳实践**：

- 用于元编程或对象 introspection（如检查属性描述符）。
- 结合 `Object.getOwnPropertyDescriptor` 分析属性细节。
- 日常遍历优先其他方法（如 `Object.keys`）。

---

### 6. Reflect.ownKeys(obj)

**描述**：返回对象自身所有键（字符串和符号）的数组（ES6+）。

**适用场景**：

- 处理包含符号键的对象（如现代库或框架）。
- 反射式编程或 Proxy 相关操作。
- 需要最全面的自身键列表。

**可能存在的陷阱**：

- **仅自身属性**：不包括原型链。
- **符号键处理**：需额外逻辑处理 `Symbol`（如 `Symbol.for`）。
- **兼容性**：ES6+，旧环境不支持。
- **混合类型**：返回数组包含字符串和符号，需类型检查。

**优缺点**：

- **优点**：最全面的自身键，支持符号；反射 API 的一部分。
- **缺点**：不含值，需额外访问；兼容性稍差。

**最佳实践**：

- 在使用符号键的代码中优先选择。
- 结合 `Reflect.get(obj, key)` 访问值。
- 确保运行环境支持 ES6（如现代浏览器或 Node.js）。

---

### 综合分析与最佳实践

#### 性能与适用性

- **小对象**：所有方法性能差异不大，`for...in` 可能稍快（无数组创建），但需检查原型。
- **大对象**：`Object.entries` 和 `Object.keys` 生成数组，内存开销稍高；缓存结果以优化。
- **现代代码**：优先 `Object.entries` + `for...of`（可读性高，安全）。
- **符号键**：仅 `Reflect.ownKeys` 支持，适合现代库。
- **不可枚举属性**：用 `Object.getOwnPropertyNames` 或 `Reflect.ownKeys`。

#### 陷阱与注意事项

- **原型链**：只有 `for...in` 遍历原型属性，需用 `hasOwnProperty` 过滤。
- **遍历顺序**：ES2015+ 通常按插入顺序（数字键升序后字符串键），但不依赖此（标准不保证）。
- **对象修改**：遍历中避免添加/删除属性，可能导致跳过或无限循环。
- **类型检查**：确保输入是对象（`typeof obj === 'object' && obj !== null`）。
- **Proxy 对象**：可能触发 getter/setter，需测试行为。

#### 最佳实践总结

1. **现代首选**：`Object.entries` + `for...of` 解构，代码清晰且安全。
2. **值或键单独处理**：用 `Object.values`（值）或 `Object.keys`（键），结合数组方法。
3. **符号键**：用 `Reflect.ownKeys`，并检查符号类型。
4. **不可枚举**：用 `Object.getOwnPropertyNames` 或 `Reflect.ownKeys`。
5. **不可变操作**：优先返回新数组（如 `Object.keys`），避免修改原对象。
6. **性能优化**：缓存方法结果（如 `Object.keys` 数组），避免重复调用。
7. **测试边缘情况**：空对象、继承属性、符号键、Proxy 对象。
